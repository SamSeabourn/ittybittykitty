/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/

/* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
   * Unfortunately, in order for <Draggable> to work properly, we need raw access
   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
   * as in this example:
   *
   * function MyComponent() {
   *   const nodeRef = React.useRef(null);
   *   return (
   *     <Draggable nodeRef={nodeRef}>
   *       <div ref={nodeRef}>Example Target</div>
   *     </Draggable>
   *   );
   * }
   *
   * This can be used for arbitrarily nested components, so long as the ref ends up
   * pointing to the actual child DOM node and not a custom component.
   */

/* binding */

/* createRoot */

/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */

/* harmony default export */

/* harmony export */

/* webpack/runtime/compat get default export */

/* webpack/runtime/publicPath */

/*#__PURE__*/

/**
   * A workaround option which can be passed if onMouseDown needs to be accessed,
   * since it'll always be blocked (as there is internal use of onMouseDown)
   */

/**
   * By default, we add 'user-select:none' attributes to the document body
   * to prevent ugly text selection during drag. If this is causing problems
   * for your app, set this to `false`.
   */

/**
   * Called when dragging starts.
   * If this function returns the boolean false, dragging will be canceled.
   */

/**
   * Called when dragging stops.
   * If this function returns the boolean false, the drag will remain active.
   */

/**
   * Called while dragging.
   * If this function returns the boolean false, dragging will be canceled.
   */

/**
   * These properties should be defined on the child, not here.
   */

/**
   * `allowAnyClick` allows dragging using any mouse button.
   * By default, we only accept the left button.
   *
   * Defaults to `false`.
   */

/**
   * `axis` determines which axis the draggable can move.
   *
   *  Note that all callbacks will still return data as normal. This only
   *  controls flushing to the DOM.
   *
   * 'both' allows movement horizontally and vertically.
   * 'x' limits movement to horizontal axis.
   * 'y' limits movement to vertical axis.
   * 'none' limits all movement.
   *
   * Defaults to 'both'.
   */

/**
   * `bounds` determines the range of movement available to the element.
   * Available values are:
   *
   * 'parent' restricts movement within the Draggable's parent node.
   *
   * Alternatively, pass an object with the following properties, all of which are optional:
   *
   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
   *
   * All values are in px.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable bounds={{right: 300, bottom: 300}}>
   *              <div>Content</div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */

/**
   * `cancel` specifies a selector to be used to prevent drag initialization.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *           return(
   *               <Draggable cancel=".cancel">
   *                   <div>
   *                     <div className="cancel">You can't drag from here</div>
   *                     <div>Dragging here works fine</div>
   *                   </div>
   *               </Draggable>
   *           );
   *       }
   *   });
   * ```
   */

/**
   * `defaultPosition` specifies the x and y that the dragged item should start at
   *
   * Example:
   *
   * ```jsx
   *      let App = React.createClass({
   *          render: function () {
   *              return (
   *                  <Draggable defaultPosition={{x: 25, y: 25}}>
   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
   *                  </Draggable>
   *              );
   *          }
   *      });
   * ```
   */

/**
   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
   * with the exception of `onMouseDown`, will not fire.
   */

/**
   * `grid` specifies the x and y that dragging should snap to.
   */

/**
   * `handle` specifies a selector to be used as the handle that initiates drag.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable handle=".handle">
   *              <div>
   *                  <div className="handle">Click me to drag</div>
   *                  <div>This is some other content</div>
   *              </div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */

/**
   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
   * instead of using the parent node.
   */

/**
   * `position`, if present, defines the current position of the element.
   *
   *  This is similar to how form elements in React work - if no `position` is supplied, the component
   *  is uncontrolled.
   *
   * Example:
   *
   * ```jsx
   *      let App = React.createClass({
   *          render: function () {
   *              return (
   *                  <Draggable position={{x: 25, y: 25}}>
   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
   *                  </Draggable>
   *              );
   *          }
   *      });
   * ```
   */

/**
   * `scale`, if set, applies scaling while dragging an element
   */

/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/************************************************************************/

/******/

/***/

/*: $Keys<DraggableCoreProps>*/

/*: $Shape<DraggableState>*/

/*: ?Document*/

/*: ?Node*/

/*: ?number*/

/*: Array<any> | TouchList*/

/*: Bounds*/

/*: ControlPosition*/

/*: Draggable | DraggableCore*/

/*: Draggable*/

/*: DraggableCore*/

/*: DraggableCoreProps*/

/*: DraggableData*/

/*: DraggableProps*/

/*: EventWithOffset*/

/*: Function*/

/*: HTMLElement*/

/*: MouseTouchEvent*/

/*: Node*/

/*: Object*/

/*: PositionOffsetControlPosition*/

/*: [number, number]*/

/*: any*/

/*: number*/

/*: string*/

/*:: interface EventWithOffset {
  clientX: number, clientY: number
}*/

/*eslint no-console:0*/

//

// $FlowIgnore

// $FlowIgnore we can't assert on HTMLElement due to tests... FIXME

// $FlowIgnore: Doesn't think elements are indexable

// $FlowIgnore: IE

// $FlowIgnore[method-unbinding]

// (we use doc.defaultView in case we're in an iframe)

// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc

// A lot faster than stringify/parse

// Add a CSS transform to move the element around. This allows us to move the element around

// Add a style to the body to disable user-select. This prevents text from

// Add events to the document directly so we catch when the user's mouse/touch moves outside of

// Add slack to the values used to calculate bound position. This will ensure that if

// Arity (props, state)

// But above left and top limits.

// By explicitly using `prop-types` you are opting into new production behavior.

// CONCATENATED MODULE: ./src/App.tsx

// CONCATENATED MODULE: ./src/components/button/index.tsx

// CONCATENATED MODULE: ./src/components/catcarrier/CarrierBottom.png

// CONCATENATED MODULE: ./src/components/oswindow/OSWindow.tsx

// CONCATENATED MODULE: ./src/index.tsx

// Call event handler

// Call event handler. If it returns explicit false, cancel.

// Can only determine if SVG after mounting

// Check if module is in cache

// Check to see if the element passed is an instanceof SVGElement

// Clone new bounds

// Compute bounds. This is a pain with padding and offsets but this gets it exactly right.

// Create a new module (and put it into the cache)

// Create an data exposed by <Draggable>'s events

// Create an data object exposed by <DraggableCore>'s events

// Create an event object with all the data parents need to make a decision here.

// Current transform x and y.

// DCE check should happen before ReactDOM bundle executes so that

// Default export is the prefix itself, like 'Moz', 'Webkit', etc

// Default to mouse events.

// Define <Draggable>

// DevTools can report bad minification during injection.

// DevTools shouldn't crash React, no matter what.

// EXTERNAL MODULE: ./node_modules/react-dom/client.js

// EXTERNAL MODULE: ./node_modules/react-draggable/build/cjs/cjs.js

// EXTERNAL MODULE: ./node_modules/react/index.js

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js

// Ensure we're running in an environment where there is actually a global

// Execute the module function

// Get bound position. This will ceil/floor the x and y within the boundaries.

// Get from offsetParent

// Get nodes. Be sure to grab relative document (could be iframed)

// Get the current drag point from the event. This is used as the offset.

// Get {x, y} positions from event.

// I see why this insanity was deprecated

// If no bounds, short-circuit and move on

// If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>

// If this element was SVG, we use the `transform` attribute.

// If this is a controlled component, the result of this operation will be to

// If we're in a pseudo-browser server-side environment, this access

// Important that this is after handle/cancel.

// Important!

// Initiate dragging. Set the current x and y as offsets

// Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.

// Keep within bounds.

// Keep x and y below right and bottom limits...

// Kills start event on core as well, so move handlers are never bound.

// Make it possible to attach event handlers on top of this one.

// Mark with class while dragging

// Might not be found entirely (not an Element?) - in that case, bail

// Note that you may have to re-test for certain things; for instance, Chrome 50

// Note we're passing `document` b/c we could be iframed

// Note: mouseMove handler is attached to document so it will still function

// Old browsers

// Only accept left-clicks.

// Prevent scrolling on mobile devices, like ipad/iphone.

// Previous versions of this lib exported <Draggable> as the root export. As to no-// them, or TypeScript, we export *both* as the root and as 'default'.

// React 16.3+

// React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find

// Recalculate slack by noting how much was shaved by the boundPosition handler.

// Remove any leftover event handlers. Remove both touch and mouse handlers in case

// Remove event handlers

// Remove selection caused by scroll, unless it's a focused input

// Reset the el.

// Return the exports of the module

// Reuse the child provided

// Save original x and y.

// See https://github.com/mzabriskie/react-draggable/pull/254

// Set left if horizontal drag is enabled

// Set top if vertical drag is enabled

// Set touch identifier in component state if this is a touch event. This allows us to

// Set x/y if a new position is provided in props that is different than the previous.

// Short circuit if handle or cancel prop was provided and selector doesn't match.

// Short-circuit if user's callback killed it.

// Simple abstraction for dragging events names.

// Snap to grid if prop has been provided

// The module cache

// The require function

// This entry need to be wrapped in an IIFE because it need to be in strict mode.

// This is deliberately excluding margin for our calculations, since we are using

// This makes it flexible to use whatever element is wanted (div, ul, etc)

// Touch handlers must be added with {passive: false} to be cancelable.

// Update the event we fire to reflect what really happened after bounds took effect.

// Used for compensating for out-of-bounds drags

// Used while dragging to determine deltas.

// Useful for preventing blue highlights all over everything when dragging.

// User can provide an offsetParent if desired.

// User-select Hacks:

// Verify that the code above has been dead code eliminated (DCE'd).

// We should still report in case we break this code.

// We're on a touch device now, so change the event handlers

// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration

// Whether or not we are currently dragging.

// Whether or not we have been dragged before.

// Works up the tree to the draggable itself attempting to match selector.

// `window` obj

// and https://github.com/mzabriskie/react-draggable/issues/266

// being selected all over the page.

// by default only accept left click

// can handle unprefixed `transform`, but not unprefixed `user-select`

// completely removed.

// const days = Math.floor((inputSeconds % 31536000) / 86400)

// define __esModule on exports

// define getter functions for harmony exports

// distinguish between individual touches on multitouch screens by identifying which

// eslint-disable-next-line no-console

// for Flow, can't seem to refine correctly

// getDefaultExport function for compatibility with non-harmony modules

// has a clean slate.

// http://fb.me/prop-types-in-prod

// https://developers.google.com/web/updates/2017/01/scrolling-intervention

// is a touch-capable device.

// no module.id needed

// no module.loaded needed

// not possible but satisfies flow

// not the right touch

// offsetLeft which is including margin. See getBoundPosition

// offsetTop which is including margin. See getBoundPosition

// on touchscreen laptops we could switch back to mouse

// onTouchStart is added on `componentDidMount` so they can be added with

// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.

// path may not exist, so bail out if it doesn't.

// prevents invariant if unmounted while dragging

// probably IE

// revert back to the old position. We expect a handler on `onDragStop`, at the least.

// skip useless drag

// so we know how much we've moved during the drag. This allows us

// some browser quirk caused a touch event to fire during a mouse move, or vice versa.

// the underlying DOM node ourselves. See the README for more information.

// this element. We use different events depending on whether or not we have detected that this

// to drag elements around even if they have been moved, without issue.

// touchpoint was set to this element.

// we start removing slack, the element won't react to it right away until it's been

// webpackBootstrap

// when the user drags quickly and leaves the bounds of the element.

// without worrying about whether or not it is relatively or absolutely positioned.

// {passive: false}, which allows it to cancel. See

//Kitties dont sleep straight after run or jog :)

//Not yet supported

//TODO: Move to config

//TODO: add to preload image script

//kittens always leave the carrier first movement

//max poop is 20 TODO: this is broken somehow
